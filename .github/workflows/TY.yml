name: 通用OpenWrt编译工作流（强化版）

on:
  workflow_dispatch:
    inputs:
      compile_threads:
        description: '编译线程数'
        required: false
        default: '1'
        type: choice
        options:
          - '1'
          - '2'

env:
  REPO_URL: https://github.com/coolsnowwolf/lede
  BUILD_DIR: lede

jobs:
  build:
    runs-on: ubuntu-22.04
    timeout-minutes: 360

    steps:
    - name: 检查代码和配置
      uses: actions/checkout@v4

    - name: 磁盘空间优化
      run: |
        echo "=== 初始磁盘空间 ==="
        df -h
        sudo swapoff -a
        sudo dd if=/dev/zero of=/swapfile bs=1G count=2
        sudo chmod 600 /swapfile
        sudo mkswap /swapfile
        sudo swapon /swapfile
        echo "=== 磁盘和内存状态 ==="
        df -h
        free -h

    - name: 清理系统缓存
      run: |
        echo "清理系统缓存..."
        sudo apt-get clean
        sudo rm -rf /usr/local/lib/android /usr/share/dotnet /opt/ghc 2>/dev/null || true
        sudo rm -rf /usr/local/lib/node_modules 2>/dev/null || true
        sudo rm -rf /var/lib/apt/lists/*
        sudo rm -rf /tmp/*

    - name: 验证配置文件
      run: |
        if [ ! -f ".config" ]; then
          echo "❌ 错误：缺少配置文件 .config"
          echo "请在工作流运行前上传 .config 文件到仓库根目录"
          exit 1
        fi
        echo "✅ 找到配置文件"
        echo "=== 配置文件预览（前30行）==="
        head -30 .config

    - name: 检查配置文件完整性
      run: |
        echo "🔍 深度检查配置文件..."
        
        # 检查基本架构配置
        if ! grep -q "CONFIG_TARGET_[a-zA-Z]" .config; then
          echo "❌ 错误：缺少目标架构配置"
          exit 1
        fi
        
        # 检查内核版本
        if ! grep -q "CONFIG_LINUX_[0-9]" .config; then
          echo "⚠️ 警告：可能缺少内核版本配置"
        fi
        
        # 检查关键包
        CRITICAL_PACKAGES=("base-files" "busybox" "dnsmasq" "dropbear" "firewall" "kmod" "libc" "opkg" "procd" "uci" "ubus")
        for pkg in "${CRITICAL_PACKAGES[@]}"; do
          if ! grep -q "CONFIG_PACKAGE_${pkg}=y" .config; then
            echo "⚠️ 警告：建议包含基础包 $pkg"
          fi
        done
        
        echo "✅ 配置文件检查完成"

    - name: 安装完整编译环境
      run: |
        echo "安装完整编译环境..."
        sudo apt-get update
        
        # 添加Python 2.7支持
        sudo apt-get install -y software-properties-common
        sudo add-apt-repository -y ppa:deadsnakes/ppa
        sudo apt-get update
        
        # 安装完整的编译工具链
        sudo apt-get install -y \
          build-essential \
          git \
          libncurses5-dev \
          libncursesw5-dev \
          libssl-dev \
          python2.7 \
          python3 \
          python3-pip \
          unzip \
          wget \
          curl \
          gcc \
          g++ \
          binutils \
          patch \
          bzip2 \
          flex \
          make \
          autoconf \
          automake \
          gettext \
          pkg-config \
          libtool \
          libc6-dev \
          m4 \
          gawk \
          sed \
          cmake \
          rsync \
          subversion \
          texinfo \
          zlib1g-dev \
          gperf \
          antlr3
        
        # 创建python2符号链接
        sudo ln -sf /usr/bin/python2.7 /usr/bin/python2
        echo "✅ 完整编译环境安装完成"

    - name: 克隆源码
      run: |
        if [ -d "$BUILD_DIR" ]; then
          echo "删除已存在的 $BUILD_DIR 目录"
          rm -rf "$BUILD_DIR"
        fi
        echo "开始克隆源码..."
        git clone --depth=1 --single-branch "$REPO_URL" "$BUILD_DIR"
        if [ $? -ne 0 ]; then
          echo "❌ 源码克隆失败"
          exit 1
        fi
        echo "✅ 源码克隆完成"

    - name: 应用自定义feeds配置
      run: |
        if [ ! -d "$BUILD_DIR" ]; then
          echo "❌ 错误：$BUILD_DIR 目录不存在"
          exit 1
        fi
        
        # 检查仓库根目录是否有feeds.conf.default文件
        if [ -f "feeds.conf.default" ]; then
          echo "📋 找到自定义的feeds.conf.default，将其复制到编译目录"
          cp "feeds.conf.default" "$BUILD_DIR/feeds.conf.default"
          echo "✅ 已应用自定义feeds配置"
          
          # 显示feeds配置预览
          echo "=== feeds配置预览（前20行）==="
          head -20 "$BUILD_DIR/feeds.conf.default"
        else
          echo "ℹ️ 未找到自定义feeds.conf.default，将使用源码默认配置"
        fi

    - name: 更新软件源
      run: |
        if [ ! -d "$BUILD_DIR" ]; then
          echo "❌ 错误：$BUILD_DIR 目录不存在"
          exit 1
        fi
        cd "$BUILD_DIR"
        echo "开始更新软件源..."
        
        # 多次尝试更新feeds
        for i in {1..3}; do
          echo "第 $i 次尝试更新feeds..."
          if ./scripts/feeds update -a; then
            echo "✅ feeds更新成功"
            break
          else
            echo "⚠️ 第 $i 次feeds更新失败"
            if [ $i -eq 3 ]; then
              echo "❌ feeds更新彻底失败"
              exit 1
            fi
            sleep 5
          fi
        done
        
        # 安装feeds
        echo "安装feeds..."
        if ./scripts/feeds install -a; then
          echo "✅ feeds安装成功"
        else
          echo "⚠️ feeds安装有错误，但继续执行..."
        fi

    - name: 应用配置
      run: |
        if [ ! -d "$BUILD_DIR" ]; then
          echo "❌ 错误：$BUILD_DIR 目录不存在"
          exit 1
        fi
        
        cd "$BUILD_DIR"
        
        echo "复制配置文件..."
        if [ -f "../.config" ]; then
          cp "../.config" ".config"
          echo "✅ 配置文件复制完成"
        else
          echo "❌ 错误：未找到.config文件"
          exit 1
        fi
        
        echo "应用默认配置..."
        if make defconfig; then
          echo "✅ 配置应用完成"
        else
          echo "❌ 配置应用失败，尝试清理后重试..."
          make clean
          make defconfig
        fi

    - name: 预编译检查和修复
      run: |
        cd "$BUILD_DIR"
        echo "🔧 执行预编译检查和修复..."
        
        # 检查配置完整性并修复
        echo "检查配置完整性..."
        
        # 确保有文件系统
        if ! grep -q "CONFIG_TARGET_ROOTFS" .config; then
          echo "添加默认文件系统配置..."
          echo "CONFIG_TARGET_ROOTFS_EXT4FS=y" >> .config
          echo "CONFIG_TARGET_ROOTFS_SQUASHFS=y" >> .config
        fi
        
        # 确保有基础包
        BASE_PACKAGES=("base-files" "busybox" "dropbear" "firewall" "kmod" "libc" "opkg" "procd" "uci")
        for pkg in "${BASE_PACKAGES[@]}"; do
          if ! grep -q "CONFIG_PACKAGE_${pkg}=y" .config; then
            echo "添加基础包: $pkg"
            echo "CONFIG_PACKAGE_${pkg}=y" >> .config
          fi
        done
        
        # 重新应用配置
        echo "重新应用配置..."
        make defconfig
        
        echo "✅ 预编译检查完成"

    - name: 编译前清理
      run: |
        echo "=== 编译前磁盘空间 ==="
        df -h
        echo "执行最终清理..."
        sudo apt-get clean
        sudo rm -rf /var/cache/apt/archives/*
        
        # 移除.git目录节省空间
        if [ -d "$BUILD_DIR/.git" ]; then
          echo "移除.git目录节省空间..."
          rm -rf "$BUILD_DIR/.git"
        fi
        
        echo "=== 清理后磁盘空间 ==="
        df -h

    - name: 下载软件包
      run: |
        if [ ! -d "$BUILD_DIR" ]; then
          echo "❌ 错误：$BUILD_DIR 目录不存在"
          exit 1
        fi
        
        cd "$BUILD_DIR"
        THREADS=${{ github.event.inputs.compile_threads }}
        
        echo "开始下载软件包（使用 $THREADS 线程）..."
        for i in {1..5}; do
          echo "第 $i 次尝试下载..."
          if make download -j$THREADS; then
            echo "✅ 软件包下载完成"
            break
          else
            echo "⚠️ 第 $i 次下载失败，重试..."
            sleep 10
          fi
        done
        
        if [ $? -ne 0 ]; then
          echo "❌ 软件包下载失败，但继续尝试编译..."
        fi

    - name: 分步编译（容错模式）
      run: |
        if [ ! -d "$BUILD_DIR" ]; then
          echo "❌ 错误：$BUILD_DIR 目录不存在"
          exit 1
        fi
        
        cd "$BUILD_DIR"
        THREADS=${{ github.event.inputs.compile_threads }}
        
        echo "开始分步编译..."
        echo "=== 当前磁盘空间 ==="
        df -h
        echo "=== 内存使用情况 ==="
        free -h
        
        echo "🔧 使用容错模式编译..."
        
        # 分步编译，每一步都检查结果
        COMPILE_STEPS=(
          "tools/compile"
          "toolchain/compile" 
          "target/compile"
          "package/compile"
          "package/index"
        )
        
        for step in "${COMPILE_STEPS[@]}"; do
          echo "=========================================="
          echo "执行编译步骤: $step"
          echo "=========================================="
          
          for attempt in {1..2}; do
            echo "第 $attempt 次尝试..."
            if make $step -j$THREADS; then
              echo "✅ $step 完成"
              break
            else
              echo "⚠️ $step 第 $attempt 次尝试失败"
              if [ $attempt -eq 2 ]; then
                echo "❌ $step 彻底失败，尝试单线程详细模式..."
                make $step -j1 V=s
                if [ $? -ne 0 ]; then
                  echo "❌ $step 单线程也失败，继续下一个步骤..."
                fi
              fi
              sleep 5
            fi
          done
        done
        
        echo "🎉 分步编译完成"

    - name: 最终编译
      run: |
        cd "$BUILD_DIR"
        THREADS=${{ github.event.inputs.compile_threads }}
        
        echo "执行最终完整编译..."
        if make -j$THREADS; then
          echo "🎉 编译成功！"
        else
          echo "❌ 最终编译失败，尝试单线程详细编译..."
          make -j1 V=s
        fi

    - name: 检查生成的文件
      run: |
        if [ ! -d "$BUILD_DIR" ]; then
          echo "❌ 错误：$BUILD_DIR 目录不存在"
          exit 1
        fi
        
        echo "🔍 查找生成的固件文件..."
        
        # 多种方式查找固件文件
        find_command="find \"$BUILD_DIR/bin\" -type f \( -name \"*.bin\" -o -name \"*.img\" -o -name \"*.gz\" -o -name \"*.trx\" -o -name \"*.elf\" \) 2>/dev/null"
        FIRMWARE_FILES=$(eval $find_command)
        
        if [ -n "$FIRMWARE_FILES" ]; then
          echo "✅ 找到以下固件文件:"
          echo "$FIRMWARE_FILES"
          echo "=== 文件大小统计 ==="
          du -sh "$BUILD_DIR/bin/" 2>/dev/null || true
          
          # 检查文件是否有效（大于1MB）
          VALID_FILES=0
          while IFS= read -r file; do
            if [ -f "$file" ] && [ $(stat -c%s "$file" 2>/dev/null || stat -f%z "$file" 2>/dev/null) -gt 1048576 ]; then
              VALID_FILES=$((VALID_FILES + 1))
            fi
          done <<< "$FIRMWARE_FILES"
          
          echo "有效固件文件数: $VALID_FILES"
        else
          echo "❌ 未找到任何固件文件"
          echo "=== 目录结构 ==="
          find "$BUILD_DIR/bin" -type d 2>/dev/null | head -20
          exit 1
        fi
        
        echo "=== 最终磁盘空间 ==="
        df -h

    - name: 上传固件文件
      if: success()
      uses: actions/upload-artifact@v4
      with:
        name: openwrt-firmware
        path: ${{ env.BUILD_DIR }}/bin/
        retention-days: 30

    - name: 快速上传固件
      if: success()
      uses: actions/upload-artifact@v4
      with:
        name: quick-firmware
        path: |
          ${{ env.BUILD_DIR }}/bin/**/*.bin
          ${{ env.BUILD_DIR }}/bin/**/*.img
        retention-days: 7

    - name: 上传编译日志
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: build-logs
        path: |
          ${{ env.BUILD_DIR }}/logs/
        retention-days: 7

    - name: 完成提示
      if: always()
      run: |
        if [ "${{ job.status }}" == "success" ]; then
          echo "🎊 编译成功完成！"
          echo "📥 固件文件可在Artifacts区域下载："
          echo "   - openwrt-firmware: 完整编译输出"
          echo "   - quick-firmware: 快速下载固件"
          echo "   - build-logs: 编译日志（用于调试）"
        else
          echo "❌ 编译过程出现错误"
          echo "💡 故障排除建议:"
          echo "   1. 检查 .config 文件配置"
          echo "   2. 查看 build-logs 中的详细错误"
          echo "   3. 确保选择了正确的目标架构和设备"
          echo "   4. 检查是否包含必要的基础包"
          echo "   5. 尝试减少编译的包数量"
          echo "   6. 检查 feeds.conf.default 配置"
        fi
